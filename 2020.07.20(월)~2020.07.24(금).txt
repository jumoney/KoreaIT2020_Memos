2020.07.20(월)

오전수업(DB)
- NVL()함수 : NULL값을 다른값으로 대처하는 함수 
	ex) nvl(commission_pct, 0)
- distinct : 중복을 없애는 명령어(2개 속성을 적을 경우 2개 합쳐 중복이 아닌 경우를 모두 출력한다.)
	ex) SELECT distinct job_id
	     FROM employees;
 - CAST()함수 : 형변환 함수 (원래값 AS NUMBER) 
(NUMBER면 정수형, 나머지 STRING등도 넣을 수 있다 AS는 알리아스가 아니라 영어 AS의 뜻을 가지고 있다 
햇갈리지 않도록 주의하자.)
 - sysdate속성으로 현재 시간을 가져올수 있다.(mySql에서는 now()함수를 통해 가져온다.)
	ex)SELECT to_char(sysdate, 'mm-dd/yyyy hh:mi:ss') FROM dual;
 - foreign key : 
	ex) CREATE TABLE i_student_hobby(
		i_student number,
		i_hobby number,
		r_dt date default sysdate,
		primary key(i_student, i_hobby),
		foreign key (i_student)references t_student(i_student),
		foreign key (i_hobby)references t_hobby(i_hobby)
		);
 -폴인 키에서 기본은 restrict고 이 restrict는 참조 중인 레코드가 있다면 지울수 없다 이며
지우고 싶다면 cascade로 바꾸면 되지만 왠만큼 기본으로 놔두자. 바꿀일이 별로 없다.

2020.07.21(화)
오전수업(DB)

- DB쿼리 :
	SELECT
	B.i_student, B.nm as student_nm
	, A.i_hobby, C.nm as hobby_nm
	FROM t_student_hobby A
	INNER JOIN t_student B
	ON A.i_student = B.i_student
	INNER JOIN t_hobby C
	ON A.i_hobby = C.i_hobby;

- INNER JOIN : 교집합(너도 있고 나도 있는것)
- LEFT JOIN : 왼쪽의 테이블을 기준으로 출력한다.

- DB쿼리 : 

*테이블 생성
CREATE TABLE t_board(
i_board NUMBER PRIMARY KEY,
title VARCHAR2(100) NOT NULL,
ctnt VARCHAR2(2000) NOT NULL,
i_student NUMBER NOT NULL,
FOREIGN KEY(i_student) REFERENCES t_student(i_student)
);

*코멘트 다는 법
COMMENT ON COLUMN t_board.i_student IS '작성자';

*insert문
INSERT INTO t_board(i_board, title, ctnt, i_student) VALUES(1, '안녕', '12121212', 3);
INSERT INTO t_board(i_board, title, ctnt, i_student) VALUES(2, '하세요', 'ㅋㅋㅋㅋㅋㅋ', 3);
INSERT INTO t_board(i_board, title, ctnt, i_student) VALUES(3, '하하', '1ㅇㅇㅇㅁㄴ', 1);
INSERT INTO t_board(i_board, title, ctnt, i_student) VALUES(4, '좋아요', 'ㅋㅇㅋㄹㅇㄴㄻㄴㅇㅁㄴ', 2);
INSERT INTO t_board(i_board, title, ctnt, i_student) VALUES(5, '크크', 'sdfdfdfdfdfdfdf', 3);

- 늘어나는 속성의 경우 컬럼을 늘려서는 안된다.(옆으로 늘리지 말고 밑으로 늘려라)

-DB 쿼리 :
*LEFT JOIN으로 조회 
	SELECT
	    *
	FROM t_student_hobby A
	LEFT JOIN t_student B
	ON A.i_student = b.i_student
	LEFT JOIN t_hobby C
	ON A.i_hobby = C.i_hobby;

*카운트 조회(like 개수)
SELECT A.*, B.i_board, nvl(B.like_cnt, 0) as like_cnt
FROM t_board A
LEFT JOIN(
SELECT i_board, COUNT(i_board) AS like_cnt
FROM t_board_like
GROUP BY i_board
)B
ON A.i_board = B.i_board;

*좋아요가 없는 개시물(like_cnt가 null인 게시물)
SELECT A.*, B.*, nvl(B.like_cnt, 0) as like_count
FROM t_board A
LEFT JOIN(
SELECT i_board, COUNT(i_board) AS like_cnt
FROM t_board_like
GROUP BY i_board
)B
ON A.i_board = B.i_board
WHERE b.i_board is null
ORDER BY nvl(b.like_cnt, 0) desc; -> null값이 제일 위로 올라오기 때문에 nvl을 써서 널을 0으로 만든다.

2020.07.22(수)
오전수업(DB)
*OracleDB정보
- 사용자 이름 : hr
- 비밀번호 : koreait2020
- 호스트 이름 : localhost
- 포트 : 1521
- SID : orcl
---------------------------------------------------------------
- index속성은 가상테이블을 만들어 들어가 있는 속성값을 순서대로 관리해 준다.(검색의 속도가 훨씬빠르다. 중간검사 -> 중간검사)
- PRYMARY KEY, 혹은 UNIQUE 는 자동적으로 인덱스가 생성된다.
- PRIMARY KEY는 NOT NULL, UNIQUE, INDEX 속성을 모두 가지고있다.

*인덱스 생성 쿼리
CREATE INDEX idx_student_age	(인덱스명을 적어준다.)
ON t_student(age);			(어디 테이블에 어떤 컬럼인지 적어준다.)

*뷰 생성 쿼리
CREATE VIEW view_boardlike_cnt		(뷰명을 적어준다.)
AS 					(알리아스 아님)
SELECT i_board, COUNT(i_board) as like_cnt	(쿼리문을 입력한다.)
FROM t_board_like
GROUP BY i_board;

*뷰 조회 쿼리
SELECT * FROM view_boardlike_cnt;

*뷰 삭제 쿼리
DROP VIEW view_boardlike_cnt;

*시험정보
핵심은 조인을 걸줄 알아야되고 그 앞에 as 붙일줄 알면 된다.

*인덱스 삭제 쿼리
DROP INDEX idx_student_age;

*유저 테이블, 유저 인덱스, 유저 뷰 보는 명령어(데이터 사전 -> 시험문제에 나옴)
SELECT * FROM user_tables;
SELECT * FROM user_indexes;
SELECT * FROM user_views;


